\documentclass[12pt,letterpaper]{article}
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{mathrsfs}

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\usepackage{fontspec}

\setromanfont{PTSerif}[
    Path=./fonts/,
    Extension = .ttf,
    UprightFont = *-Regular,
    BoldFont = *-Bold,
    ItalicFont = *-Italic,
    BoldItalicFont = *-BoldItalic,
]

\hypersetup{%
  colorlinks=true,
  linkcolor=blue,
  linkbordercolor={0 0 1}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\hwnumber{6}
\newcommand\student{Ivan Zhytkevych}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagestyle{fancyplain}
\headheight 35pt
\lhead{\student}
\chead{\textbf{\Large Complexity Homework \hwnumber}}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\NewDocumentCommand{\set}{o m}{%
  % <code>
  \IfNoValueTF{#1}
    {\{#2\}}
    {\{#1 \mid #2\}}%
  % <code>
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem 6.1}
Додаємо окремо до $M_1$ стрічку та використовуємо її для двійкового лічильника на основі вхідного слова.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem 6.2}
\begin{itemize}
    \item Для додавання використаємо двійкову систему із відповідним алгоритмом додавання чисел
із бітом переносу, тобто за властивістю двійкової системи будемо мати логарифмічну складність
по пам'яті.

Для множення використовуємо знову ж таки двійкову систему. Застосовуємо алгоритм множення
 в стовпчик. Маємо логарифмічну складність по пам'яті.
 \item  Загалом, перевірка однаковості рядків не вимагає додаткової пам'яті, лише декілька станів.
 \item Будемо використовувати додаткову стрічку для запам'ятовування позиції у рядку $y$. І послідовно перевіряти однаковість символів по довжині $|x|$ починаючи з цієї позиції, записаної на додатковій стрічці. Будемо інкрементувати лічильник на додатковій стрічці при 'поразці' перевірки на певній позиції. При успіху МТ буде повертати 1, якщо всі позиції пройдено (лічильник досяг значення $|y| - |x| + 1$), то повертаємо 0.

\end{itemize}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem 6.4}

Рахуємо послідовно нулі, далі рахуємо одиниці, при чому при знаходженні нуля між одиницями
повертаємо 0 одразу. Далі потрібно порівняти обидва числа (кількість нулів та одиниць). Повертаємо
1, якщо вони збігаються. Маємо логарифмічну складність по пам'яті.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem 6.5}

Використовуємо двійковий лічильник із підтримкою від'ємних чисел. При значенні лічильника менше за 0 ми повинні повернути 0, оскільки ця ситуація можлива лише при неправильній дужковій структурі. При зчитуванні '(' додаємо до лічильника 1, при ')' віднімаємо одиницю. При використанні двійкової системи маємо логарифмічну складність по пам'яті.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem 6.6}

Будуємо аналогічну систему попередній задачі, окрім:
\begin{itemize}
    \item Маємо різні види дужок, тому встановлюємо кожен лічильник для окремого типу на окремій стрічці.
    \item Можуть бути такі недопустимі ситуації --- $([)]$. Це можна загалодити, використовуючи ще одну окрему стрічку для запам'ятовування поточного відкритого типу дужок.
\end{itemize}
Використовуємо двійкові лічильники та константну кількість комірок для запам'ятовування типу. Отже маємо логарифмічну складність по пам'яті.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}

